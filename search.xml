<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《格鲁夫给经理人的第一课》读书笔记]]></title>
    <url>%2F2020%2F0723%2Fgroves-first-lesson-for-managers-reading-notes.html</url>
    <content type="text"><![CDATA[背景在职场，越往上走，越觉得管理是门学问。很好奇我的开发经理(Dev Manager)是如何工作的，他们每年给我们这些 “一线开发” 制定KPI，那他们的KPI是如何定义的，他们的产出在哪里？平时他们除了开会，就是回复邮件，这些真的能带来产出么？带着这些疑问，我淘到了一本英特尔前CEO格鲁夫写的一本 《High Output Management》, 里面详细介绍了如何衡量一个经理人的产出以及如何提升其产出的方法，令我感触颇多。这本书也帮助我理解了公司和团队日常开不同会议的目的和作用，以及经理人在其中的角色。 概括这本书主要聚焦于企业中的中层经理人，教导他们如何提升自己的产出，管理好自己的团队。首先 中层经理并不是一个具体的title，他可以是一名工程师，或是会计师，无论怎样，他都是一个组织的骨干。 这本书的中心是围绕 产出导向 这四个字展开的。企业需要产出和利润，在这个目标的驱动下，企业中的每个人都需要产生对应的产出，这里面中层经理人的贡献是不可忽视的，他们就如同一支润滑剂，无缝衔接着决策层和工程师团队。产出导向主要涵盖以下三个方面: 经理人产出定义和优化 生产法则 团队意识 + 个人意识 虽说英特尔是个制造业公司，但格鲁夫提出的这些概念其实在互联网公司也得到了很广泛的应用。只不过互联网公司架构更加扁平，也有业内约定俗成的一套方式方法，例如各种Agile的实践，ceremonies等。但万变不离其宗，都是为了解决公司内部流程的问题，从而提高整个公司的产出。 核心下面我们从三个维度(why, what and how)来展开 产出导向 这个核心概念。 Why为什么我们强调产出? 结论应该是显而易见的: 往低说是保住饭碗; 往高说是获得更多晋升的机会，帮助公司创造更多的价值; 往远说更是帮助自己提升职场的竞争力。 格鲁夫在写这本书的时候说: 今天，处在人生中场的中年中层干部，失业的可能性大约是十年前的两倍。我观察身边的EMBA朋友们的职场动态，状况还可能越来越糟。其实我们不是任何“老 板”的员工，我们每个人都是自己职业生涯的员工。没人欠我们一个饭碗，你必须自己当家。认清只有你自己(不是你的“老板”)才是自己的主人。为打赢越来越 激烈的“保职战”，我们得好好提升自己的“产能”，增加自己的附加价值与生产力，不能有丝毫懈怠。一天24小时我们都该竭尽全力追求进步。 这段话在今天(2020)也显得格外应景和睿智。在Covid-19疫情下, 无数企业忙着裁员和重组，大量人员失业。在新西兰，甚至空姐都得去超市做货架员。在这种极端情况下，我们不得不去思考我们自己的定位，我们自己的产出是什么，我们的核心竞争力又在那里？ What经理人的产出那产出导向是什么呢? 如何定义一个人的产出? 下面我们就来用格鲁夫的公式来解释一个经理人的产出, 同样，也适用于我们自己。 经理人的产出=组织产出加总=a×A+b×B+c×C+…(a、b、c……代表管理杠杆率，A、B、C……代表各种管理活动.) 经理人产出是由两部分构成的: 直接管辖和间接影响力所及的组织产出加总. 先来解释下名词:杠杆率: 各单项管理活动所带来的产出, 可以理解为单位产出.管理活动: 可以理解为管理总量. 这个公式很好理解，每个经理人手下不止一个团队，每个团队也不止一个管理活动。当然，这些管理活动的定义是视情况而定的。举例来说，我们team现在的Delivery Manager直接管理着两个团队: 一个产品团队, 一个SDK团队. 产品团队对SDK团队有依赖; 由于我们的后台服务依赖Core Platform, 所以我们的经理还得经常和Core Platform的经理开会。除此之外，前台产生的数据最终需要数据/AI团队整理并生成报告送给客户, 所以我们也得经常和AI团队交流，确保数据的完整和准确。所以我们经理的产出总和就是直接管理的俩团队的产出总和加上间接影响到的Core Platform以及AI团队的产出。至于每个管理活动的杠杆率和管理活动总量我们无需纠结，只要知道他们代表什么就够了，因为在软件行业我们不这么定义产出，而是使用Agile的方式方法定义，例如scrum，我们有team velocity和spring goal，以及一系列的Agile ceremonies确保团队产出的稳定。 生产法则在这点上，制造业和软件开发相似性很高。格鲁夫是这样定义生产的: 按预定的时间、可接受的品质以及可能的最低成本，依据顾客的需求制造及运送产品。 流程和限制步骤完全和我们交付产品给公司或是客户的要求一模一样！英特尔的生产步骤可以总结如下: 制造: 营销和研发人员将一大堆的产品资料化为业务人员理解的销售策略，这个将资料转化成策略的过程便是制造. 组装: 将各种销售策略组合成完美的销售计划。在新产品上市的会议上，营销人员将最合适的策略和必要的市场资料(如竞争商品的价格和存货状况)结合产品说明、宣传册及活动挂图向业务人员报告。 测试: 在真正上市之前应先有一场虚拟的上市发布会。在此会议上，被挑选出来的业务代表要对策略及销售工具等等作出反应。如果反映不佳，亦即测试结果不良，整个策略就必须修改或重新制定，以符合原定的营销及销售目标. 软件开发也有流程，就是我们熟悉的SDLC: 1.计划: 明确需求, 设定交付时间线.2.分析: 调研, 定义目标，例如项目目标以及产品的功能和操作.3.设计: 流程图，架构图，UI设计，伪代码，文档，商业逻辑等.4.实现: 功能实现.5.测试以及集成: 单元测试，回归测试，烟雾测试等，集成系统，部署.6.维护: 发布后线上监控, 修复问题等. 在生产法则中，格鲁夫强调了一个很重要的概念: 限制步骤。 流程中其他的步骤都是围绕这个限制步骤展开的，可以将限制步骤理解为最耗时，成本最大的一个步骤。那软件开发中限制步骤是什么呢？个人认为是实现阶段，即开始写代码的阶段。大多数情况下，在软件开发过程中，人工都是最贵的，一旦项目开始，就很难走回头路了。所以围绕实现前的3个步骤一定要仔细调研，给出清晰地需求和设计，而且要先做MVP(Minimum Viable Product); 在开发团队实现MVP的过程中，PO(Product Owner), BA(Business Analyst)要开始准备下一阶段的需求会议以及设计，这就是实现了时间互偿。 指标这其实就是我们在平时工作中的 “Spint Goal”。一个Sprint一般是两周，也就是说在两周中，team要完成定量的工作，如果没有完成，即是没有达标。在Scrum中，每个team都有其 “Velocity”，例如每个Sprint是58，即两周时间，这个team可以完成58个story point。PO就可以根据team的速率来决定下一个Sprint要commit多少个point。有了指标才好评判一个team是否有稳定的产出，也容易帮助经理发现和解决问题，从而提高他们管理活动的杠杆率。 杠杆率一个活动如果有比较高的杠杆率，即表示同样的投入之下，这项活动会比杠杆率较低者有更高的产出。 这个反应在我们日常的工作中就是事物的优先级(Priority)。优先级高的，自然是对公司重要的，势必要给公司带来更大的产出，或者减少极大的成本开支。在日常的生产，或是开发过程中，经理人要发力在那些能给自己带来最大产出的工作上，这也符合公司的宏观目标。比方说：公司P有两个项目A和B，当A项目第一阶段告落得时候，公司要决定是继续投钱在A项目还是把重心移到客户更需要的B项目。结论显而易见，公司选择了B项目，那么经理人就需要把他的时间更多的放在B项目上，A项目每周查看几次就可以了，确保不会出现大问题即可。 团队意识 + 个人意识“单丝不成线，孤木不成林”。经理人要想 “成事” 离开团队是绝对不行的，而且经理人产出的公式已经很好地反映出了这一点：产出都是团队合作的结果。 说到团队合作，我相信一线的工程师们肯定有很多想吐槽和质疑的点，甚至会有人觉得团队合作就是笑话，还不如自己一个人效率高等等。这种想法其实就是把自己限制在了工程师这个角色中，而不是跳脱出来站在一个更高的高度上看问题。人类世界，大部分生产活动都需要团队合作才能成功。我们开发产品，也要时刻记着我们的目的：按预定的时间、可接受的品质以及可能的最低成本，依据顾客的需求制造及运送产品, 而不是完成每一个特定的功能. 单兵作战能力再强，也敌不过对手聚而攻之。如果发现团队里有成员带不动，或者合作有问题的时候，我们是需要去解决他们个人的问题，而不是否定团队合作。 所以，除了团队合作外，个人意识也很重要。每个团队成员都需要各司其职，各尽所能, 才能保证团队有最高的产能。格鲁夫举了这样一个例子： 不管教练再怎么强，仍然得看队员们的努力，就像在球场上运球、上篮还是得靠球员的表现。 格鲁夫认为：如果一个人没有做好他的事，只有两种原因可以解释，要么是不为，要么就是不能。前者是态度有问题，缺乏诱因；后者则是无能为力。对于后者，大部分情况团队内的成员们会互相帮助，共同克服困难。如果真是因为能力不济，那么就要反思招聘和培训流程的问题。至于第一种情况，若是缺乏诱因，那么可以对症下药，找到激励员工的方法；如果员工就是 “老油条”，那么就要考虑绩效评估，多劳多得，保证一碗水端平。 只有做到 “点对点” 的沟通，经理人才能更好地了解团队的情况，针对不同成员制定不同的策略，最终保证的是整个团队的高产出。这也是为什么国外互联网公司经常有员工和经理(或者组长) “一对一” 的会议，就是确保沟通顺畅，及时解决问题。 How我们已经知道了产出导向的含义，那如何提升它们呢？我们先前已经知道经理人产出的公式： 经理人的产出=组织产出加总=a×A+b×B+c×C+…(a、b、c……代表管理杠杆率，A、B、C……代表各种管理活动.) 那具体方法也很明确： 安排好管理活动的优先级，剔除低杠杆率的管理活动，代之以高杠杆率的活动 提升每一项管理活动的杠杆率 经理人每天要从事很多活动，需要区分清楚哪些能带来产出，哪些不能；并根据公司的目标，将高产出的管理活动放在优先级较高的位置上，确保团队优先执行。例如：每个sprint的planning，和refinement是必须放在高优先级的位置上的，因为这两个会议决定了当前这个sprint要产出和能产出什么。除了给管理活动排序，经理人也要知道如何提升高优先级管理活动的杠杆率，例如提升sprint planning和refinement的效率。 经理人要在开这两个会前做好充足的准备，或者让负责会议的product owner做好充足的准备，不要在会议中还在补充backlog中的task；经理人也要在会议前及时解决或者反馈团队遇到的阻碍，这样方便团队合理安排capacity(每个人每个sprint的时间)。经理人也要及时决策，不要犹豫不决，这样有可能会影响团队士气，导致效率低下。总之还有很多提升管理活动杠杆率的方法，核心就在于要和团队及时沟通，及时解决各种问题，这样每个管理活动的效率才能令人满意。 让流程的每个环节可控软件开发有计划，分析，设计，实现，测试和维护几个步骤. 每个步骤都应该严格控制完成时间，以确保限制步骤有充足的时间去执行，不能无休止的去计划和设计。举个亲身经历的案例：我们公司要做一款 “Server-Driven”的移动端产品, 我们称之为 “white label app”, 意思就是任何一个客户接入时，我们不需要大量修改我们的代码库，只需要修改针对不同客户的配置文件就能自动生成专属于该客户的移动端产品。理念任何人都能理解，但是架构设计却没有一个人能够(愿意)去拍板决定，所以我们当时的经理带着我们连续和不同高层开了一个月的会，把“white label”的概念讲了一遍又一遍，最终还是我们自己做了决定。这样下来前前后后浪费了一个月的开发时间，也让一线开发们参加了很多不必要的会议。 这就是典型的没有把控好软件开发流程的一个例子，做了很多杠杆率不高的事情，导致产品推迟了发布。其实每个步骤都可以建立指标，例如产品设计我们要在两周之内完成，出多少张原型图，这些都是可以量化的。像英特尔有 先行指标，线性指标，趋势指标等等， 软件开发流程也可以借鉴，避免做重复无用功。 管理的必经之路: 开会格鲁夫将开会分为两大类: 任务导向型会议和过程导向型会议. 会议是从事管理工作必经的媒介,你绝对无法避免开会，但你能让会议更有效率. 任务导向型会议通常是产生决策的会议，这类会议杠杆率很高，例如Sprint Planning，在这种会议上，团队要制定下个Sprint要完成的任务，决定产出；过程导向型会议通常是一些知识分享，注重与会者过程中学到什么，例如我们经常举办的 “lunch and learn”，分享一个话题，大家一起讨论，分享。这类会议有时也可以显著提升团队或者个人的产出效率，例如一些团队内部知识分享，能有效打破知识壁垒，也利于内部成员了解一些架构设计，避免日后返工。 以上是针对团队的会议，那针对个人呢？其实产出最终都会落到每个人的头上，经理人也需要市场关注团队内每个个体员工的日常工作情况。所以 “一对一” 会议就应运而生了。 一对一会议经常由经理或者是你的team lead来主持，大概每两周或者每个月举行一次。内容基本上就是询问你的近况，有没什么问题和担忧；如果临近绩效考核，还会和你谈谈绩效的问题。总之作为经理人，你要在一对一会议上想办法让部属把觉得心烦的事情说出来，这样才能帮助他们去解决，从而提升工作效率。要做好一个倾听者，集学生和教练的角色于一身，做好笔记，让部属觉得你很重视他们的反馈，这样才能提升一对一会议的效率，你也做了存档，避免忘记。 一对一会议的杠杆率是巨大的，试想你和部属每个两周开一次一对一会议，30分钟，就会影响他接下来两周，也就是80个小时的工作成果；如果在一对一会议中你们能建立和加强你们之间的信任关系，那对产出的提升是事半功倍的。同时，你也能了解部属的工作，建立共同的信息基础。 培训与激励(绩效)相信这是大部分一线开发都经历过的事情：入职培训和绩效考核。入职培训个人感觉杠杆率不高，基本是走个过场；但技术培训则不同，杠杆率极高。比方说我入职F公司，进去第二天就接受了当时项目架构的培训，对我之后的工作的确是起了事半功倍的效果，阅读代码也能更快的理解含义，最终出活儿的速度和质量都得到了显著提升。 很明显，培训员工具有极高的管理杠杆率。举个例子，如果你必须为你的部门上4堂课，假设每堂1小时的课你要花3小时准备，那么你花在这次培训上的时间是16小时。你的部门如果有10个人，第二年他们在公司的工作时间将大约在2万小时左右。如果你的培训能将部属的绩效提高1个百分点，对公司而言便是多了200小时——而这只是你花了16小时的结果。没有受到良好培训的员工就算再怎么努力，结果仍然会是缺乏效率、成本增加、客户不满，有时甚至还会使公司陷入危机。 所以一个公司有完善的培训流程是很重要的，尤其是大公司，否则对新人来说是种折磨；对公司来说则可能造成极大的损失。 至于激励，我们的目的是用激励产生效能，也就意味着我们的激励要符合部署的内心。简单来说，有些人要钱，有些人要权，不只是权力，也有话语权。格鲁夫有句话讲的很好：激励是用来提高绩效的，而不是改变一个人的情绪或者态度。或许他的态度变积极，但是最终我们要看到新的产能出现。 就像治病救人一样，激励也是要对症下药。上图是著名的马斯洛需求理论。大部分员工是为了赚钱来工作的，那么公司就要满足最底层的需求，给员工至少每年和通胀差不多的工资涨幅；再高一层就是安全感，公司针对这部分员工可能需要提供保险补贴。我身边就有一个极好的例子，他选择的公司都是本地大企业(银行)，提供保险补贴，贷款优惠等，因为他有3个孩子，两位老人需要照顾，就职于这样的公司，隐性的福利大于工资的可能涨幅了；中间这层则是人类情感的需求，人们需要别人的认同，希望和志同道合的人在一起工作，也希望做的产品有价值甚至有趣； 至于剩下的两种需求，格鲁夫认为它们才是真正激励我们在工作上追求更卓越表现的原因。追求地位意味着你想在公司承担更多的责任和有更大的话语权，这点对于高级开发是极其重要的。高级做到一定年限后，你的下一个目标很可能就是带团队，做一个lead，这样可以让你跨越一个台阶，也会让你发现另一个不一样的世界。不过在现实生活中，升到一定阶段无法再升，或者达到了你升职的目标后，你的动力又会下降，会感觉没了前进的动力，这时候你就需要最顶层的 自我实现，只有它才能让你的工作动力不再受限，才能激励你不断向上突破。 格鲁夫具体介绍了两种内在动力：精益求精型和成就导向型. 我身边这两类朋友不在少数，第一种是iOS开发大神，自己做产品，给Apple亚洲区Unicode做贡献，不断向下钻研，人生理想是写出自己的编译器；第二种是不断的设定目标和达成任务，不断地在挑战自己的极限，完成一个又一个看似不可能的任务。 对于公司和经理人来说，个人觉得能做好前三点就很不错了，后两点个体差异太大，便不再多做讨论。经理人应该多了解部属，给予公平公正的奖惩，认证核实员工KPI，不要让员工寒心。 总结刚工作的时候很不理解自我的价值在哪里，为什么我能拿这份钱，有市场行情的因素，但是我的产出又在那里？公司一线开发都是每天做着相同的工作，那绩效为何有高有低? 读完格鲁夫的书，我对这些疑问也大致有了答案，知道了我每个sprint出的feature和最终客户的销售业绩的联系，知道了自己的价值所在，为公司和客户赚了多少钱，知道了这些，我明白了我的产出，也明白了公司和经理安排这些考评流程和会议的意义所在，也知道了我自己时间的价值和我下一步的追求。总的来说有种拨开云雾，见到光明的感觉，很通透，很敞亮。也希望这篇文章能够帮助到你，对自己的产出有个大致认识和了解。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>管理</tag>
        <tag>Team Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift函数派发机制]]></title>
    <url>%2F2019%2F0510%2Fswift-function-dispatch-mechanism.html</url>
    <content type="text"><![CDATA[一个令人困惑的小问题大家请看下面这段代码(摘自objc.io twitter的swift quiz) 12345678910111213141516protocol Drawing &#123; func render()&#125;extension Drawing &#123; func circle() &#123; p rint(&quot;protocol&quot;)&#125; func render() &#123; circle()&#125;&#125;class SVG: Drawing &#123; func circle()&#123; print(&quot;class&quot;) &#125;&#125;SVG().render()// what&apos;s the output? 请给出你的答案😄 根据当时的统计，43%选择了protocol, 57%选择了class。但真理往往掌握在少数人手中，正确答案是protocol。objc给出的解释是: circle函数声明在protocol的extension里面，所以不是动态派发，并且类没有实现render函数，所以输出为protocol. 更为准确的说法应该是: extension中声明的函数是静态派发，编译的时候就已经确定了调用地址，类无法重写实现。 派发机制在更深入研究Swift函数派发机制之前，我们有必要了解下函数派发的基本知识。函数派发就是CPU在内存中找到该函数地址并调用的过程。函数派发有三种类型: 静态派发，函数表派发和消息派发。当我们在选择时，需要平衡程序的执行效率和动态性，选择最适合当下情景的派发方式。 直接派发直接派发是三种派发方式中最快的。CPU直接按照函数地址调用，使用最少的指令集，办最快的事情。当编译器对程序进行优化的时候，也常常将函数内联，使之成为直接派发方式，优化执行速度。我们熟知的C++默认使用直接派发方式，在Swift中给函数加上final关键字，该函数也会变成直接派发的方式。当然，有利就有弊，直接派发最大的弊病就是没有动态性，不支持继承。 函数表派发这种方式是编译型语言最常见的派发方式，他既保证了动态性也兼顾了执行效率。函数所在的类会维护一个”函数表”，也就是我们熟知的虚函数表。该函数表存取了每个函数实现的指针。每个类的vtable在编译时就会被构建，所以与直接派发相比只多出了两个读取的工作: 读取该类的vtable和该函数的指针。理论上说，函数表派发也是一种高效的方式。不过和直接派发相比，编译器对某些含有副作用的函数却无法优化，也是导致函数表派发变慢的原因之一。而且Swift类扩展里面的方法无法动态加入该类的函数表中，只能使用静态派发的方式，这也是函数表派发的缺陷之一。 我们来看如下代码: 123456789class Vehiche &#123; func run() &#123;&#125; func brake() &#123;&#125;&#125;class Car: Vehiche &#123; override func brake() &#123;&#125; func speedUp() &#123;&#125;&#125; 当前情景下，编译器会创建两个函数表: 一个属于Vehiche类，另一个属于Car类，内存布局如下: 12let car = Car()car.brake() 当调用函数brake时，过程如下: 读取该对象(0XB00)的vtable. 读取brake函数指针0x222. 跳转到地址0X222，读取函数实现. 消息派发这种派发方式是三种里面最动态的一种方式。由于Swfit使用的依旧是Objc的运行时系统，所以这里的消息派发其实也就是Objc的Message Passing(消息传递)。 1id returnValue = [someObject messageName:parameter]; someObject就是接收者，messageName就是选择器，选择器和参数一起被称为 “消息“。当编译时，编译器会将该消息转换成一条标准的C语言调用： 1id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter); objc_msgSend函数回一句接收者和选择器的类型来调用适当的方法，它会去接收者所属类中搜索其方法列表，如果能找到，则跳转到对应实现；若找不到，则沿着继承体系继续向上查找，若能找到，则跳转；如果最终还是找不到，那就执行边界情况的操作，例如 Message forwarding(消息转发)。 这样做的好处在哪里呢？这种运作方式的关键在于开发者可以在运行时改变函数的行为，也就是我们常说的Swizzling。Swizzling经常用来配置服务以及hack某些测试case。 KVO就是使用swizzling实现的。 这种派发方式的流程步骤似乎很多，所幸的是objc_msgSend会将匹配的结果缓存到fast map(快速映射表)中，而且每个类都有这样一块缓存；若是之后发送相同的消息，执行速率会很快。 Swift如何派发函数了解了函数派发的基本知识，我们来看看Swift如何处理函数派发以及如何证明该种派发。我们先来看一张总结表: 从上表中我们可以直观的总结出：函数的派发方式和以下两点相关联: 对象类型; 值类型总是使用直接派发(静态派发，因为他们没有继承体系) 函数声明的位置; 直接在定义中声明和在扩展中(extension)声明 除此之外，显式的指定派发方式也会改变函数其原有的派发方式，例如添加final或者@objc关键字等等；以及编译器对特定函数的优化，例如将从未被重写的私有函数优化成静态派发。 下面我们就这四个方面来分析和探讨Swift的派发方式，以及证明其派发方式。 对象类型如上文所述，值类型，也就是struct的对象总是使用静态派发; class对象使用函数表派发(非extension)。请看如下示例: 1234567class MyClass &#123; func testOfClass() &#123;&#125;&#125;struct myStruct &#123; func testOfStruct() &#123;&#125;&#125; 现在我们使用如下命令将swift代码转换为SIL(中间码)以便查看其函数派发方式: 1swiftc -emit-silgen -O test.swift 输出结果如下:、 123456...sil_vtable MyClass &#123; #MyClass.testOfClass!1: (MyClass) -&gt; () -&gt; () : @$s4test7MyClassC0a2OfC0yyF // MyClass.testOfClass() #MyClass.init!allocator.1: (MyClass.Type) -&gt; () -&gt; MyClass : @$s4test7MyClassCACycfC // MyClass.__allocating_init() #MyClass.deinit!deallocator.1: @$s4test7MyClassCfD // MyClass.__deallocating_deinit&#125; 首先swift会为class添加init和@objc deinit方法，为struct添加init方法。在文件的结尾处就会显示如上代码，它展示了哪些函数是函数表派发的，以及它们的标识符。由于struct类型仅使用静态派发，所以不会显示sil_vtable字样。 函数声明位置函数声明位置的不同也会导致派发方式的不同。在Swift中，我们常常在extension里面添加扩展方法。根据我们之前总结的表格，通常extension中声明的函数都默认使用静态派发。 12345678910111213141516protocol MyProtocol &#123; func testOfProtocol()&#125;extension MyProtocol &#123; func testOfProtocolInExtension() &#123;&#125;&#125;class MyClass: MyProtocol &#123; func testOfClass() &#123;&#125; func testOfProtocol() &#123;&#125;&#125;extension MyClass &#123; func testOfClassInExtension() &#123;&#125;&#125; 我们分别在protocol和class中声明一个函数，再在其extension中声明一个函数; 最后让类实现协议的一个方法，转换成SIL代码后如下: 1234567891011...sil_vtable MyClass &#123; #MyClass.testOfClass!1: (MyClass) -&gt; () -&gt; () : @$s4test7MyClassC0a2OfC0yyF // MyClass.testOfClass() #MyClass.testOfProtocol!1: (MyClass) -&gt; () -&gt; () : @$s4test7MyClassC0A10OfProtocolyyF // MyClass.testOfProtocol() #MyClass.init!allocator.1: (MyClass.Type) -&gt; () -&gt; MyClass : @$s4test7MyClassCACycfC // MyClass.__allocating_init() #MyClass.deinit!deallocator.1: @$s4test7MyClassCfD // MyClass.__deallocating_deinit&#125;sil_witness_table hidden MyClass: MyProtocol module test &#123; method #MyProtocol.testOfProtocol!1: &lt;Self where Self : MyProtocol&gt; (Self) -&gt; () -&gt; () : @$s4test7MyClassCAA0B8ProtocolA2aDP0a2OfD0yyFTW // protocol witness for MyProtocol.testOfProtocol() in conformance MyClass&#125; 我们可以很直观的看到，声明在协议或者类主体中的函数是使用函数表派发的; 而声明在扩展中的函数则是静态派发。 值得注意的是: 当我们在protocol中声明一个函数，并且在protocol的extension中实现了它，而且没有其他类型重写该函数，那么在这种情况下，该函数就是直接派发，算是通用函数。 指定派发方式给函数添加关键字的修饰也能改变其派发方式。 final添加了final关键字的函数无法被重写，使用直接派发，不会在vtable中出现。并且对Objc runtime不可见。 dynamic值类型和引用类型的函数均可添加dynamic关键字。在Swift5中，给函数添加dynamic的作用是为了赋予非objc类和值类型(struct和enum)动态性。我们来看如下代码: 123struct Test &#123; dynamic func test() &#123;&#125;&#125; 我们赋予了test函数动态性。将其转换成SIL中间码后如下: 12345678// Test.test()sil hidden [dynamically_replacable] @$s4test4TestVAAyyF : $@convention(method) (Test) -&gt; () &#123;// %0 // user: %1bb0(%0 : @trivial $Test): debug_value %0 : $Test, let, name &quot;self&quot;, argno 1 // id: %1 %2 = tuple () // user: %3 return %2 : $() // id: %3&#125; // end sil function &apos;$s4test4TestVAAyyF&apos; 我们在第二行可以看到test函数多了一个“属性”: dynamically_replacable, 也就是说添加dynamic关键字就是赋予函数动态替换的能力。那什么是动态替换呢? 简而言之就是提供一种途径，比方说，可以将Module A中定义的方法，在Module B中动态替换，如下所示: 1234// Module Astruct Foo &#123; dynamic func bar() &#123;&#125;&#125; 12345678// Module Bextension Foo &#123; @_dynamicReplacement(for: bar()0 func barReplacement() &#123; ... // Calls previously active implementation of bar() bar() &#125; 添加dynamic关键字并不代表对Objc可见。 @objc该关键字可以将Swift函数暴露给Objc运行时，但并不会改变其派发方式，依旧是函数表派发。举例如下: 123class Test &#123; @objc func test() &#123;&#125;&#125; SIL代码如下: 1234567891011121314151617181920212223...// @objc Test.test()sil hidden [thunk] @$s4test4TestCAAyyFTo : $@convention(objc_method) (Test) -&gt; () &#123;// %0 // user: %1bb0(%0 : @unowned $Test): %1 = copy_value %0 : $Test // users: %6, %2 %2 = begin_borrow %1 : $Test // users: %5, %4 // function_ref Test.test() %3 = function_ref @$s4test4TestCAAyyF : $@convention(method) (@guaranteed Test) -&gt; () // user: %4 %4 = apply %3(%2) : $@convention(method) (@guaranteed Test) -&gt; () // user: %7 end_borrow %2 : $Test // id: %5 destroy_value %1 : $Test // id: %6 return %4 : $() // id: %7&#125; // end sil function &apos;$s4test4TestCAAyyFTo&apos;...sil_vtable Test &#123; #Test.test!1: (Test) -&gt; () -&gt; () : @$s4test4TestCAAyyF // Test.test() #Test.init!allocator.1: (Test.Type) -&gt; () -&gt; Test : @$s4test4TestCACycfC // Test.__allocating_init() #Test.deinit!deallocator.1: @$s4test4TestCfD // Test.__deallocating_deinit&#125; 我们可以看到test方法依旧在“虚函数列表”中，证明其实函数表派发。如果希望test函数使用消息派发，则需要额外添加dynamic关键字。 @inline or static@inline关键字顾名思义是想告诉编译器将此函数直接派发，但将其转换成SIL代码后，依旧是vtable派发。Static关键字会将函数变为直接派发。 编译器优化Swift会尽可能的去优化函数派发方式。我们上文提到，当一个类声明了一个私有函数时，该函数很可能会被优化为直接派发。这也就是为什么当我们在Swift中使用target-action模式时，私有selector会报错的原因(Objective-C 无法获取 #selector 指定的函数)。 派发总结最后我们用一张图总结下Swift中的派发方式: 从上表可见，我们在类型的主体中声明的函数大都是函数表派发，这也是Swift中最为常见的派发方式；而扩展大都是直接派发；只有再添加了特定关键字后，如@objc, final, dynamic后，函数派发方式才会有所改变。除此之外，编译器可能将某些方法优化为直接派发。例如私有函数。 如何选择派发方式讲了这么多函数派发的方式，那对我们有什么用呢？或者说如何选择派发方式呢？ 我总结了两点: 帮助我们理解一些“奇怪的”行为，例如为何extension中的函数无法被子类继承，为何需要添加@objc甚至是dynamic后才能被重写。 提供选择类型的条件，例如您的app对性能要求很苛刻，那尽量使用值类型；并且对引用类型方法添加关键字描述。 总的来说，如何选择还是取决于业务类型。首先要确定使用引用类型还是值类型，因为它们也部分决定了函数的派发方式；之后确定是否给函数添加关键字，例如@objc，final或dynamic，以达到准确描述该函数的目的。]]></content>
      <categories>
        <category>底层原理</category>
        <category>开发基础</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS App启动的奥秘]]></title>
    <url>%2F2019%2F0420%2Fthe-mystery-of-ios-app-launch.html</url>
    <content type="text"><![CDATA[随着智能手机，平板在中国普及率的上升，人们越来越依赖移动设备进行娱乐、消费，由此催生出的App更是层出不穷。根据苹果2019年2月的数据，目前AppStore上的App数量已经超过220万，比2018年同期增长了近10万个App。2015年6月到2016年6月可谓是App发展的高速时期，仅仅一年时间就增长了50万个App；同时期也是中国互联网+的黄金时期，各种创业项目，平台推出了各式各样的移动App产品。 那么，随着App的爆发式增长，我们越来越清晰地发现：大多数App是无法长期停留在用户手机里的。今天这篇文章，我们将从一个开发者的角度来思考：如何提升用户体验，让我们的App在同类产品中脱颖而出，最终能够长期稳定的存在于用户手机之中。 每当我们说到用户体验，我们往往想到的是优化界面，交互方式等。这些固然重要，但这更多的是产品和UX的职责。作为开发，我们更需要考虑他们无法完成的事情，更加高端的事情，比方说：优化App的启动流程。 为什么要考虑App的启动时间这个问题乍看上去有点废话连篇的意思，哪个用户不希望App能够飞速的打开? 哪个公司不希望自己的App能有这样好的性能？但这个问题，其实质是希望帮助开发人员理顺业务、服务的初始化思路，以及构建项目的方式。 在展开来说之前，我们需要定义下什么是App的启动： 通俗来讲，就是从用户点击App图标开始，到看到第一个页面的时间间隔。细分来看，App的启动分两种：冷启动和热启动。冷启动：App启动前，内核没有为它分配相应的进程。热启动：App冷启动后，用户将App退出至后台，再进入的过程。 热启动没什么好说的，能做的通用的事情非常少。App从后台回来直接进入AppDelegate生命周期函数，剩下的就是App自身的业务逻辑，如果要优化，也仅是业务上的优化，恢复数据，做一些同步。所以本篇我们只展开讲冷启动(后文将用启动代替冷启动)的流程和优化。BTW: 笔者建议先从热启动开始优化，毕竟大部分的性能瓶颈都在自家代码里。 App启动步骤概览从大方向讲，App启动步骤分为三个阶段： 从系统exec()调用到我们App的main()为止 (main函数之前) main()执行之后 首屏渲染结束(至第一个界面的viewDidAppear:，nib loading) 整个流程如下： 概括来讲：内核先将我们的App加载进内存，之后加载一个“中间件”: dynamic loader(简称:dyld)。之后dyld会负责分析App的Mach-O文件以加载所需的dynamic libraries。之后利用Rebasing和Binding修正内部和外部指针指向。最后加载runtime组件，runtime组件加载好后就会向需要初始化的object发送消息，开始初始化。 至此，main函数之前的步骤结束。之后的流程就是我们耳熟能详的生命周期了，App开始在AppDelegate里面初始化我们自定义的服务以及渲染首屏等。 Crash Course (名词速成班)相信你看到这里或多或少已经对其中的一些名词感到陌生甚至”讨厌”了。这里面可能除了runtime，其他的你都没接触过。所以，这一小节我们针对上述流程涉及到的名词加以解释，并帮助大家扩充下底层知识，更好的理解main函数之前发生的事情。 内核内核是操作系统的核心。iOS和OS X使用的都是XNU内核。在这里，我们不需要知道XNU内核的详细架构，只需要知道它的功能即可，例如：提供基础服务，像线程，进程管理，IPC(进程间通信)，文件系统等等。 上图阐述了内核是如何加载我们的App到进程中的。在这幅图里有两个关键点： PAGEZERO是怎么回事？ 为什么我们的App起始位置是不确定的？ 这就要涉及到下一个知识点：ASLR。 ASLR(地址空间布局随机化) + Code Sign简单来说，就是当应用映射到逻辑地址空间的时候，利用ASLR技术，可以使得应用的起始地址总是随机的，以避免黑客通过起始地址+偏移量找到函数的地址。ASLR和Code Sign是iOS两种主要的安全技术。相信大家对Code Sign并不陌生，在底层上进行code sign的时候，加密哈希是针对Mach-O的每一个page，这就保证了dyld在加载Mach-O的时候可以确保单个page不被篡改。 那PAGEZERO的作用又是什么呢？当系统利用ASLR分配了随机地址后，从0到该地址的整个区间会被标记为不可访问，意味着不可读，不可写，不可被执行。这个区域的大小苹果给出了官方的解释： 针对32位进程，至少4KB 针对64位进程，至少4GB 这块区域可以帮助我们捕获任意的空指针和指针截断。(例如:64位指针转32位的时候) 虚拟内存理解了虚拟内存能够更好地帮助我们理解iOS内部机制。首先，现有的操作系统大都使用逻辑地址和物理地址这两个概念。逻辑地址可以理解为是虚拟地址，为的是”欺骗App”；但经过硬件和软件的配合，逻辑地址可以被映射到实实在在的物理地址上。 逻辑内存是被分页的，就像一整块蛋糕被分成多个小块一样。然后通过页表，映射到物理内存。物理内存是被分为很多帧的，和逻辑内存的页相对应。(页面和帧的对应关系主要是通过页表来保存) 总的来说，逻辑地址空间(虚拟内存)大大提高了CPU的使用效率，使得多个程序可以被同时、按需加载进内存。 iOS中，每一个进程都是一个逻辑地址空间，并且同时映射到物理内存上。这种映射不只是”一对一”关系，还可以是“一对0，多对一”。 当逻辑内存地址在物理内存上没有对应的地址时，就会发生page fault错误。这时候内核就会停止当前线程，分配一块物理内存给当前的逻辑地址；如果我们有两个进程运行在不同的逻辑地址空间，它们是可以同时映射到同一物理内存的，这时候就需要它们share部分的RAM了。 那么问题来了，既然两个进程的某些逻辑地址空间可以同时映射到相同的物理地址，那么如果它们一方需要修改该地址内容的话，该如何是好呢？这就需要介绍下iOS的Copy-On-Write(COW)机制了。 当一个进程试图向DATA page写入数据时，内核会立刻创建一个拷贝，并映射到另一个物理RAM 至于什么是DATA page， 我们稍后在Mach-O章节介绍。 当Copy-On-Write发生的时候，会产生dirty page, 与之相对的则是clean page。Clean page是那种内核可以之后从磁盘恢复的拷贝；而dirty page则包含了进程信息，无法被其他进程重用。 图中RAM 3所在的page就是一个dirty page。 在dyld章节我会再次提到clean page和dirty page，着重讲解dyld是如何通过修改Mach-O的__Data段，从而产生dirty page。 Mach-OMach-O，全称是Mac object file format, 是一种文件类型。哪些文件是Mach-O呢？ Exectuable: 例如我们App bundle下的二进制文件 Dylib: 动态库，好比Windows下得DLL Bundle: 指的是无法被链接，只能使用dlopen加载的动态库，例如Mac平台下的plug-ins Image: 以上三个 Framework: 包含资源文件、头文件等的dylib 段(Segments)Apple的Mach-O文件可以分为三大部分： Header: 头部， 包含可执行的cpu架构，文件类型等，例如arm64，x86；MH_EXECUTE。(如果合并过架构，则会是Fat Header) Load commands: 加载命令，包含文件的组织架构和在虚拟内存中的布局方式 Data: 数据，包含load commands中需要的各个段(segment)的数据，每一个Segment的大小都是Page的整数倍。 Data部分示意图: 上例中，TEXT段大小是3页，DATA和LINKEDIT各是一页。Page的大小取决于硬件的架构，例如在arm64架构下，每页是16KB；其余架构下每页是4KB。 Data部分包含哪些segment呢？绝大多数mach-o包括以下三段:__TEXT: 代码段，只读，包括函数，和只读的常量，例如C字符串，上图中类似__TEXT, __text的都是代码段__DATA: 数据段，读写，包括可读写的全局变量, 静态变量等，上图类似中的__DATA, __data都是数据段__LINKEDIT: 如何加载程序, 包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。 下图是我个人项目NetworkTransport的Mach-O文件布局: 从图中可以清晰的看到__TEXT和__DATA. 那__LINKEDIT去哪里了呢？据我观察__LINKEDIT似乎被隐藏了，但是其存储的元数据却是可见的，例如下图中笔者选中的Dynamic Loader Info一栏，Rebase的信息一览无余的展现在我们面前。 并且，当你展开Load Commands选项的时候，就会发现__LINKEDIT的段布局信息。 部分(Sections)Section是段(Segment)中的子区域, 每个section包含的内容不同，大小也没有限制。例如在__TEXT segment里， text section包含的是可执行的机器码; cstring section包含C类常量字符串。值得注意的是，这里面的常量是没有重复的，原因是静态连接器在做构建的时候，合并了有相同值的常量。 PIC(Position Independ Code, code-gen)在dyld拼接不同的dylibs的时候，dylibA也需要知道如何调用dylibB。但是由于每页都被签名的原因，dyld是无法直接去修改指令的。这时候code-gen，也就是动态PIC会在__DATA段为dylibA创建一个指针，指向dylibB的某个地址。比方说：dylibA想调用dylibB的sayHello方法，code-gen会先在Mach-O的__DATA段中建立一个指针指向sayHello，再通过这个指针实现间接调用。 dyld (dynamic loader/linker)加载dylibsdyld是iOS平台上的二进制加载器或者说动态链接器，也是内核的得力”小助手”。它负责将程序依赖的各种动态库加载到进程。同时也肩负着修复内部和外部指针指向的责任(传送门，dyld开源代码)。下面我们就来看看dyld是如何帮助内核完成加载工作的。 从上图可以看到，ALSR将dyld也加载到了进程中一个随机地址，此时的dyld和App享有同样的权限。其实从加载完dyld之后，内核要做的事情就结束了，之后的所有步骤都由dyld完成。首先，dyld会读取Mach-O文件中的指令(Load commands)，去将其依赖的各个动态库映射到当前的逻辑地址空间，如果该动态库还依赖其他动态库，比方说下图的A库依赖C库，dyld会递归的将没加载过的dylib都加载到当前进程中(具体由ImageLoader完成)，直到所有的动态库加载完毕。Apple官方称，一个App通常会加载1到400个dylibs! 不过幸运的是，这其中大部分是系统的dylibs，Apple在操作系统启动的时候，也已经帮我们提前计算和缓存了这些dylibs的信息，这样dyld加载它们的时候就会快很多。 Dirty &amp; Clean Page我们在上文提到: 当Copy-On-Write发生时，该page会被标记为dirty，同时会被复制。下面我们通过一个实例来进一步理解虚拟内存和Mach-O布局，以及dyld是如何产生出dirty page的。 上图展示的是两个不同的进程共享同一个dylib的使用场景。我们从左到右看，左边的进程1先加载了该动态库，通过读取Load Commands, dyld知道要先加载__TEXT段(可读，可执行)，上图__TEXT段大小为3个page，但是dyld只会先将第一个page映射到物理RAM。之后读取__DATA段信息(可读可写)，在Mach-O章节中，我们已经知道，__DATA段存储了全局变量，而大部分的全局变量又都被初始化为0，所以在第一次被加载的时候，虚拟内存技术会将这些全局变量直接分配到一些page上(上图是3个page)，不从磁盘中读取。接着dyld加载__LINKEDIT段，并将其映射到物理RAM2。当dyld加载__LINKEDIT(只读)段时，会被告知需要做一些”修正”以便dylib可以被顺利运行，这时，dyld就需要向__DATA段写入一些数据了。当写入发生时，该page对应的物理RAM就包含了当前进程信息，变成了dirty page。最终，这个dylib占用了8个page，包含2个clean page，一个dirty page(其余还未被映射)。 这时，如果有第二个进程同时引用了这个dylib，那么会发生什么呢？第一步同样是加载__TEXT段，不同的是，这次内核会发现在物理内存的某一处，已经加载过对应的__TEXT段，所以这次只是简单地把映射重定向下，不做任何IO操作。__LINKEDIT也是如此，区别就是这次变快了许多。当内核在寻找__DATA段的时候，它先会去检查是否还存在干净的副本，如果有，则直接映射；如果没有则需要重新从磁盘中读取，读取后dyld做修正，所以这个page也会变为dirty page。当dyld完成了修正过程后，__LINKEDIT也就不被再需要，内核可以在适当的时候释放其映射的物理RAM。 总结下: 当两个进程共享一个dylib时,使用虚拟内存技术映射物理RAM，把原本16个脏页面变成了两个脏页面和一个干净的共享页面。但上例是针对Apple自己提供的动态库，如果是我们自己写的cocoatouch framework，不排除当两个进程共用一个framework时，可以共享某些page。例如两个App都依赖Alamofire网络库时，一个App先行加载其Mach-O文件到物理内存；当另一个App加载Alamofire时，直接映射即可。 Rebase &amp; Binding这个步骤就是上文说到的”修正”步骤, 同时也用到了上文提到的PIC技术。Reabse是指修正内部指针指向; Binding是指修正外部指针指向。如下图所示: 指向_malloc和_free的指针是修正后的外部指针指向。而指向__TEXT的指针则是被修复后的内部指针指向。 这个步骤发生的原因我们上文提到过: ASLR。由于起始地址的偏移，所有_DATA段内指向Mach-O文件内部的指针都需要增加这个偏移量, 并且这些指针的信息可以在__LINKEDIT段中找到。既然Rebase需要写入数据到__DATA段，那也就意味着Copy-On-Write势必会发生，dirty page的创建，IO的开销也无法避免。 Binding是__DATA段对外部符号的引用。不过和Rebase不同的是，binding是靠字符串的匹配来查找符号表的，虽说没有多少IO，但是计算多，比Rebase慢。 使用如下命令可查看所有Resabe和Binding的修复: 1xcrun dyldinfo -rebase -bind -lazy_bind NetworkTransport.app/NetworkTransport Objc Runtime简介Objective-C runtime是Objc这款语言的运行时函数库(传送门，Runtime开源代码)，负责支持我们日常用到的各种动态特性，例如Target-Action，Associated Objects，Method Swizzling等。当然，功能觉不仅限于此，运行时库更像是一个桥阶层，帮助Objc和其他语言更好地协同工作。 Objc运行时库有很多的DATA数据结构，这些大都是系统类，这些系统类就会有很多的指针，例如指向其方法和超类。几乎所有的这些指针的修正都会在上一步完成。不过Objc runtime还需要做如下一些事情: 为每一个类生成一张函数表: 在Objc里我们可以使用字符串来初始化一个类，原理就是该类拥有函数表。 将分类(Category)里定义的扩展添加到函数表里: 如果分类override的原类的方法，则运行时会将其添加到函数表上方，调用时先用Category中定义的方法。 确保选择器的唯一性: 和上一个类似，Objc是依靠Selector的，所以确保其唯一性就保证了调用的正确性。 Load vs Initialize在Objc时代，NSObject中有两个很特殊的方法: +load 和 +initialize，它们被用于类的初始化。 +load当类或者是Category被添加到Objc Runtime时，+load方法即被调用。一个很典型的例子就是Method Swizzling，由于Apple”自底向上”的初始化策略，当我们想替换系统的某个实现时，一般都会在自定义的类中重写+load方法，实现相关代码，已达到替换的目的。 父类+load方法 先于 子类+load方法执行;主类+load方法 先于 Category的+load方法执行;不同类+load方法调用顺序不确定。 下面我们来看看部分和+load方法相关的Objc runtime的源码，以加深对+load的理解。首先是文件objc-runtime-new.mm 中的 prepare_load_methods(header_info *hi) 函数： 123456789101112131415161718192021void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; runtimeLock.assertLocked(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class realizeClass(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); &#125;&#125; 这个函数是将那些实现了+load方法的类和Category找出并实现(realized), 之后将其加入对应的loadable列表。其中 _getObjc2NonlazyClassList和 _getObjc2NonlazyCategoryList两个方法就是找出这样的类和Category。Non lazy意味着它们实现了+load方法，与之对应的则是lazy class，它们没有实现+load方法，所以不会在App启动的时候初始化，而是在收到第一次消息时初始化，可谓名副其实的懒加载。Mach-O的non lazy类可以在__DATA, __objc_nlclslist部分看到。 12345678910111213static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); &#125; prepare_load_methods中还调用到了schedule_class_load方法，在该方法里第9行我们可以看到: 函数对传入参数的父类进行了递归调用，以确保父类优先的顺序。 当类和Category准备好后，Objc runtime就可以对它们的+load方法调用了。打开文件objc-loadmethod.m，找到其中的call_load_methods函数。 1234567891011121314151617181920212223242526272829void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren&apos;t any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 这个函数有两点值得注意: 第12行和第26行的auto release pool操作，这意味着我们在自定义+load方法是不需要自己添加autorelease的block，Objc runtime帮我们处理了。 第17行和第21行，类的+load先于Category调用。 我们来看下call_class_loads的实现，call_category_loads方法和它异曲同工，就不详细介绍了。 1234567891011121314151617181920212223242526static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging()); &#125; (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) free(classes);&#125; 最关键的在第21行: (*load_method)(cls, SEL_load)。这意味着+load方法的调用不是我们熟知的 objc_msgSend(消息机制)，而是直接使用其内存地址的方式调用。这也意味着，父类、子类和分类中的+load方法的实现是被区别对待的。如果子类实现+load方法而父类没有实现，则父类中的+load方法不会被调用；如果主类和分类都实现了+load方法，则两个都会被调用，不过Category的+load方法会后调，这也为我们实现Swizzling提供了契机。 +initialize+load方法在Swift中已经被废弃, 官方推荐使用+initialize来完成之前在+load中完成的事情。+initialize方法会在类或其子类收到第一条消息(方法调用)前调用。属于懒加载，节省系统资源，避免浪费。 Swift3.1废弃了该方法, 不过可以用Objc的Category做该Swift类的扩展，依旧可以使用该函数；纯Swift环境下也有替代方法，会在之后的文章中介绍。 打开objc-runtime-new.mm文件，找到lookUpImpOrForward方法: 1234567891011121314151617IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; ... if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; runtimeLock.unlock(); _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.lock(); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won&apos;t happen. 2778172 &#125; ... &#125; 当调用某个类的方法时，Objc runtime会使用这个函数去查找或者转发该消息。如果该类没有被初始化，则调用 _class_initialize方法来初始化。 123456789101112131415161718192021222324252627282930void _class_initialize(Class cls)&#123; assert(!cls-&gt;isMetaClass()); Class supercls; bool reallyInitialize = NO; // Make sure super is done initializing BEFORE beginning to initialize cls. // See note about deadlock above. supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; _class_initialize(supercls); &#125; ... #if __OBJC2__ @try#endif &#123; callInitialize(cls); if (PrintInitializing) &#123; _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;, pthread_self(), cls-&gt;nameForLogging()); &#125; &#125; ...&#125; 第12行的递归调用保证了父类先于子类初始化；第21行调用callInitialize，代码如下: 123456void callInitialize(Class cls)&#123; ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); asm(&quot;&quot;);&#125; 可以看出+initialize方法的调用和普通函数调用一样，走的都是发送消息的流程。也就是说，无论如何，父类的+initialize都会被调用，而且如果Category实现了+initialize方法，则会”覆盖”掉主类的+initialize方法(Category的实现在函数表中优先于主类)。 而且还带来一个问题: 如果子类没有实现+initialize方法，那么父类的+initialize方法会被调用多次。如果想确保自己的+initialize方法只执行一次的话，有两种方式: 判断当前Class是否是该类 使用dispatch once token(和初始化一个Singleton一样) BTW, 无论是+load还是+initialize，都不需要在自己的实现里调用super load或者是super initialize。 Main函数的调用dyld调用UIApplicationMain()。 总结下: 内核加载App和dyld到进程中，dyld加载所有依赖的dylibs，修正所有DATA page，之后Objc runtime初始化所有类，最后调用main函数。 如何优化App启动时间熬过了理论部分，现在我们来看看如何将其应用到实际开发中，来提升我们App的启动速度。 Apple已有的优化Apple的dyld 3(目前使用版本)与之前的dyld 2相比有了显著的优化。dyld 3由三个部分构成: 进程无关的Mach-O解析器 进程相关的启动回调引擎 启动回调缓存服务 启动回调(Launch Closure)是dyld 3引进的一个新概念，它是指启动你App所有的必要信息。比方说: 你的App用到哪些动态库，指针偏移量，代码签名位置等等。 在dyld 2时代，所有我们之前提到的启动步骤都是发生在内核分配给你的进程中的(in-process); 而在dyld 3中，关于Mach-O文件的解析发生在App第一次安装或者是之后的更新过程中。解析过后，关于App启动的信息会被存到磁盘的某处，供App启动时使用。这两步大大提升了App加载的速度，系统库是有共享缓存的，所以加载速度不会慢，但我们自己App中也会有很多依赖库，每次根据@rpath查找，映射也是很耗时的工作，而且从App下载之后，这些依赖库也不会再变了，把它们放到out of process中实为明智之举。 上图中虚线以上部分就是App第一次下载或更新时dyld会做的事情。虚线以下就是当App加载到进程中后dyld会做的事情, 除了需要从缓存中读取和验证信息之外，其他步骤都是一样的。 Apple为什么要这样做？除了我们已经提到的性能优化，还有两个主要原因: 安全和可靠性。先说可靠性: 将这些步骤移出进程意味着dyld的大部分工作就像是一个普通的守护程序，Apple的工程师可以用标准工具去测试它，提升可靠性；至于安全性，Apple认为最容易被攻击的步骤是解析Mach-O头部和查询依赖库。攻击者可以搞乱App的@rpath路径，或者替换为其它library来完成@rpath confusion attacks。 所以Apple将其放入守护进程中加载。除此之外，符号表查找是另一项耗时工作，也完全可以放在进程外执行。因为除非更新软件和修改依赖库，否则该依赖库的符号表的内部偏移量是不会变的。 项目优化在优化之前，我们需要知道如何测量启动时间，为什么启动时间会慢以及多长时间的启动时间是可被接受的。 推荐的启动时间Apple推荐的启动时间是400ms, 当然最好是在App支持的最低配设备上达到这个标准。最长不要超过20s，否则系统会直接kill掉这个App。 如何测量启动时间Apple提供一个内置的环境变量来记录App启动时间(pre-main): DYLD_PRINT_STATISTICS。 具体配置方法如下: 之后启动App，在console中就可看到如下信息: 值得一提的是: dyld很智能，它会自动扣除Debugger的插入时间，所以不用担心Dev版本时间与发布版本不同。 优化启动时间基于上文的console信息，我们的优化可以从4个方面来开始: 第一: 减少动态库的依赖。在iOS平台下，尽量减少项目所依赖的动态库; 如果无法减少，尝试将不同动态库合并。在项目开发阶段，有些程序员偏爱创建CocoaTouch Framework，觉得分离出业务逻辑以及依赖资源对开发和以后维护都有好处。但是，当这样做的时候，也需要考虑下App的启动时间以及性能，是否值得这样做。Apple的WWDC2016(Session 406)给出了一个例子: 一个项目依赖26个动态库，dylibs加载时间是240毫秒; 当将其合并成2个动态库时，加载时间变为20毫秒，可以说性能显著提高。 第二: 减少指针的使用。从上图中我们可以发现, rebase和binding的时间占据了最多的时间消耗。也就是说dyld修复指针指向花费了300多毫秒。从上文我们知道，dyld修复的指针都位于__DATA段，所以我们需要做的很简单，减少项目中指针的使用。如何减少? 如果你的项目使用纯Objc开发，那就要适当减少类的个数，根据WWDC2016(Session 406)，Apple工程师的说法，项目中包含100，1000个类没什么太大的overhead，但要是5000到20000以上，则加载时间会多700到800毫秒。如果工程使用Swift居多，甚至是纯Swift，那么Apple建议能使用struct则使用struct，因为struct是值类型，不会引入指针(使用偏移量)。 第三: 优化Objc建立时间。这一步包含四个步骤: 注册类 更新类实例变量偏移(例如SDK更新) 注册Category 选择器的唯一性 这一步其实不用我们来优化，因为大部分的工作Apple已经帮我们做了，比方说ivar的偏移，这些会在rebase &amp; binding步骤完成。 第四: 初始化。在iOS平台下，如果项目使用Objc编写，尽量少使用+load方法，如果非要使用, 替换为+initialize，延迟加载。如果项目已经使用Swift编写，那就没什么优化的了，Apple暗地里帮我们调用了他们自己的initializer(dispatch_once), 确保Swift class不会被初始化多次。 不过Apple给的启动时间的信息还是太少，除了前三步，最后一步其实是可以度量的。现在的iOS App很多都在使用Cocoapods或是Carthage加载第三方依赖库。如果我们想获得每一个这样的依赖库初始化耗时时间，该怎么做呢？简单说就是Swizzling +load方法加上Instrument Static Initializers工具来追踪时间消耗，具体步骤可以参考这篇文章: 如何精确度量 iOS App 的启动时间. 这篇文章大致介绍了下App启动的流程, 涵盖的知识点比较多，无法在有限的篇幅里面再扩展更多。今后的文章里会有针对某一个知识点的深入挖掘，敬请期待! 参考链接Objective-C +load vs +initialize从 dyld 到 runtimeApp Startup Time: Past, Present, and FutureOptimizing App Startup Time如何精确度量 iOS App 的启动时间]]></content>
      <categories>
        <category>开发基础</category>
        <category>优化</category>
        <category>底层原理</category>
      </categories>
      <tags>
        <tag>dyld</tag>
        <tag>Mach-O</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇]]></title>
    <url>%2F2019%2F0419%2Fopening.html</url>
    <content type="text"><![CDATA[关于我我是一名移动开发者，也做Web和混合开发，目前有6年的开发经验。 最早接触的是iOS开发， 那是在大三尾巴上的时候，那个暑假去魅族实习，挣了万把块钱，就”败了”一台MBP 13。当时买它的主要原因还不是想做Apple的开发，是源于我们的Team Lead。他从微软回来后加盟的魅族，也在微软做过Scrum Master, 带领团队。他提到在美国，老美们都用Mac开发，说它是开发利器，加上我们当时做Ruby on Rails，每次看他”秀”终端操作和工具的时候，总觉得那才是一个开发应该有的样子。当然你用其他系统一样可以开发，一样可以使用终端操作。除此之外，我还想学iOS开发，毕竟魅族当时也被誉为”中国的Apple”，我们的产品经理也是苹果粉，天天在爱范儿关注着各类信息。就这样，在他们的持续熏陶下，我踏上了iOS开发的道路。 整个大四一年算是学习iOS的入门阶段，尤其是刚开始，完全搞不懂内在逻辑，只能把别人代码拿下来，跑通了就算谢天谢地了。就这样断断续续的学习，直到本科毕业。毕业后加入了一家旅游公司，算是腾讯系，一开始在里面做Java，负责优化网站搜索引擎，有深度，但是很枯燥。做了一个月后，本来我以为我就要在Java的道路上一去不复返时，公司来了两个iOS开发，负责移动端的研发工作。那时的我就像发现救命稻草一样，赶紧和领导商量能不能调去移动组。领导也很快答应了。刚来的移动负责人增民也很开心，毕竟又多一个”小弟”，而且还做过一段时间iOS，上手应该很快。没成想上手开发才知道我对很多知识点还是一知半解，写出的代码用他的话说就是”out of control”。但他依旧没”放弃”我，让我和另一个iOS开发(Matt, 从PHP转行过来)一起正式开始了iOS的升级打怪之路。 就这样过了半年，我从一个行业小白慢慢踏进了这行的门，理解了基本的UI开发，熟悉了UIKit。我们三个也成了好朋友，虽说那时候(2014年)我们公司就开始实行996，但我们还是会在有限的时间内一起出去搞团建。直到现在我们依旧联系，聊聊技术，聊聊国内的生活。也是从那时起，我开始写博客，不过没坚持多久我就离职了，收拾好行囊奔赴新西兰求学。 来了新西兰用了半年时间(有效读书时间)拿下研究生学位，并在读书期间和奥大教育系合作，开发了一款教学App; 还找到了一份移动开发工作(local本地公司)，之后顺利拿下了绿卡。之后就跳槽到现在的公司，目前是Fiserv高级移动开发兼Scrum Master。 重开博客写这篇博客的时候我已经28岁了，国内很多这个年龄的开发已经开始转管理岗了。相比国内，国外好些，做开发的生命周期长点，新西兰公司也不太在乎你的年纪，干的动你就干。但即将30岁，我总得想清楚自己以后的路怎么走，要成为什么样的人。移动开发是我的本职工作，自然要精，但怎样算精？学习无止境，时间有限，不要瞎学。 移动开发最火的时候已经过去，现在网上不少iOS开发抱怨不好找工作了，拿不到那么高的工资了。但细细分析就会发现这群人中大部分都做着和刚入行差不多的事情，也基本都局限在UI的开发上; 网络，本地存储，线程这些基本的操作也都局限在会用而已。那如何才能摆脱这种困境，完成iOS的进阶呢？ 笔者认为，一个优秀的iOS开发，必然不仅仅局限在iOS的世界中。与其相关的任何技术，都应该有所积累和个人见解，并且善于总结，iOS的世界很宏大，为了避免无效的积累，有一套自我学习的标杆和方向是格外重要的。以下知识点就是我总结的iOS进阶之路知识体系。 开发基础/进阶(Cocoatouch Frameworks, Runtime, 编译, 内存, 线程等) 测试(Unit/UI Test, PEN Testing, Performance Test, TDD等) 架构(MVC, MVVM, MVP，响应式编程) CI/CD(DevOps, Jenkins, fastlane, 以及一些轻量级工具等) 网络(服务器的实现，缓存优化，认证及安全等) 存储(沙盒机制，持久化方案，Keychain) 安全(本地数据保护，网络安全，反编译和代码混淆) 多媒体(音频，视频，图形图像) 版本控制(Git, Code Review等) 证书(原理，重新签名等) 优化(统计埋点，App瘦身，电量优化等) 跨平台方案(Flutter, RN, 实现原理) 智能时代(ARKit, CoreML) 软实力提升(敏捷开发，项目管理) Android开发 网上有很多iOS知识体系的脑图，大家也可以参考。重要的是找到适合自己学习路线，将平日的学习有的放矢的归类。 博客的宏观路线笔者的博客名: Full Stack Mobile Developer。看上去可能不好理解。我在此稍作解释。就如我上文提到的: 一个优秀的移动开发，必然不仅仅是局限在移动的世界中。无论是网络知识还是安全知识，都应该有涉猎，并有自己的一套解决问题的逻辑, 技术选型，风险评估等等。总而言之就是: 对于移动开发，从产品的设计到发布这个过程中，你能提供所有环节的技术支持和团队管理能力。这些如果都能很好地完成，那么这名移动开发就可以称为”全栈移动开发”，而且满足无论是组长还是技术组长的考核要求。 本博客就建立在这个目标之上，之后的文章也都会归属于以上的大类。同时我也会维护一个github仓库，把博客涉及到的代码资源公开，以方便读者们学习和交流。]]></content>
      <categories>
        <category>知识体系</category>
        <category>软实力</category>
      </categories>
      <tags>
        <tag>自我总结</tag>
      </tags>
  </entry>
</search>
